# **Tutorial: Building an IoT Metering Network with LoRa Mesh**

## **Introduction**

This guide walks you through setting up a LoRa-based mesh network for IoT metering devices using the provided `mesh.cpp` code. This system allows multiple devices to communicate and relay messages over long distances, forming a self-healing and scalable network.

## **Prerequisites**

- LoRa-enabled IoT devices (such as WisBlock modules)
- A development environment supporting Arduino or PlatformIO
- Basic knowledge of C++ and embedded systems
- Libraries for FreeRTOS, LoRa, and relevant device drivers

---

## **1. Understanding the Mesh Code**

The `mesh.cpp` file provides a complete mesh networking implementation using LoRa. It allows devices to:

- Join the network
- Exchange messages via direct and multi-hop communication
- Synchronize a network map
- Handle message queues and event-driven communication

### **Key Components**

- `init_mesh()`: Initializes the mesh system
- `mesh_task()`: Manages the mesh network in an infinite loop
- `send_to_mesh()`: Sends data to a specific node or broadcasts it
- `mesh_check_rx()`: Handles incoming messages
- `mesh_check_tx()`: Handles message transmission completion
- `send_map_request()`: Requests a network map update

---

## **2. Setting Up the Mesh Network**

### **Step 1: Install Required Libraries**

Ensure your development environment has the following:

- FreeRTOS for task handling
- LoRaWAN or SX1276 driver for LoRa communication
- Arduino or PlatformIO for embedded programming

Example installation for Arduino:

```cpp
#include <Arduino.h>
#include <LoRa.h>
#include <FreeRTOS.h>
```

---

### **Step 2: Initialize Mesh in Your Code**

Modify your main program file (`main.cpp`) to initialize the mesh network.

#### **Example Code**

```cpp
#include "mesh.cpp"

// Define a mesh events structure
mesh_events_s mesh_events = {
    .map_changed_cb = on_map_update, // Callback when the network map updates
    .data_avail_cb = on_data_received // Callback for incoming messages
};

// Callback function to handle incoming data
void on_data_received(uint32_t from, uint8_t *data, uint16_t size, int16_t rssi, int8_t snr) {
    Serial.printf("Received from %08X: %s\n", from, (char *)data);
}

// Callback function for network map updates
void on_map_update() {
    Serial.println("Network map updated!");
}

// Initialize the mesh network
void setup() {
    Serial.begin(115200);
    init_mesh(&mesh_events);
}

void loop() {
    // Main application logic
    delay(5000);
}
```

---

### **Step 3: Running the Mesh on IoT Devices**

1. **Flash the code to all devices**
    
    - Each node will automatically generate a unique ID based on its MAC address.
    - Devices will synchronize their routing tables with the network.
2. **Power on multiple devices**
    
    - Devices will start communicating and discovering each other.
3. **Monitor Serial Output**
    
    - Check the debug logs to verify that the mesh network is forming.
    - Messages like `Mesh NodeId = XXXXXXXX` indicate successful initialization.

---

## **3. Sending and Receiving Data**

### **Step 1: Sending Data to Another Node**

You can send messages directly to a node using its address:

```cpp
uint32_t target_node = 0x6FA6BC6C;  // Replace with actual node address
uint8_t message[] = "Meter reading: 123";
send_to_mesh(false, target_node, message, sizeof(message));
```

### **Step 2: Broadcasting Data to All Nodes**

For broadcasting a message to all nodes in the mesh network:

```cpp
uint8_t broadcast_msg[] = "Network-wide alert: Low battery!";
send_to_mesh(true, 0, broadcast_msg, sizeof(broadcast_msg));
```

### **Step 3: Handling Incoming Data**

Modify the `on_data_received()` callback to process received data:

```cpp
void on_data_received(uint32_t from, uint8_t *data, uint16_t size, int16_t rssi, int8_t snr) {
    Serial.printf("Received from %08X: %s\n", from, (char *)data);
    // Implement logic to process meter readings
}
```

---

## **4. Network Synchronization and Routing**

The system automatically syncs the node map and updates routing.

### **Step 1: Manually Requesting a Network Sync**

If you need to force a network sync:

```cpp
send_map_request();
```

### **Step 2: Viewing the Mesh Network Map**

To print the network topology to the Serial Monitor:

```cpp
print_mesh_map();
```

---

## **5. Handling a Broken Network**

The system simulates nodes that are out of range:

```cpp
#define BROKEN_NET
#define BROKEN_NODE_1 0x6FA6BC6C
#define BROKEN_NODE_2 0xCBE0E4F5
#define BROKEN_NODE_3 0x2BD56908
```

- This ensures the mesh can dynamically reroute data through available nodes.

---

## **6. Debugging and Optimization**

### **Step 1: Check Serial Logs**

Monitor messages such as:

- `Send queue is full` â†’ Increase `SEND_QUEUE_SIZE`
- `LoRa Packet received` â†’ Data successfully received
- `Unknown node, force map update` â†’ New nodes detected

### **Step 2: Adjust Synchronization Timings**

Modify these values to optimize battery life and responsiveness:

```cpp
#define INIT_SYNCTIME 30000     // Initial sync every 30s
#define DEFAULT_SYNCTIME 600000 // Default sync every 10 minutes
```

---

## **Conclusion**

By following this guide, you now have a working IoT mesh network using LoRa. This setup is ideal for:

- Smart metering (e.g., water, gas, electricity)
- Environmental monitoring (e.g., temperature, humidity)
- Remote asset tracking

You can expand this system by:

- Integrating cloud connectivity via a gateway
- Enhancing security with encryption
- Implementing advanced routing algorithms

---

Would you like additional features, such as a GUI for network visualization or a cloud-based dashboard? ðŸš€